package org.onosproject.ngsdn.tutorial;


import org.onosproject.core.ApplicationId;
import org.onosproject.mastership.MastershipService;
import org.onosproject.net.ConnectPoint;
import org.onosproject.net.DeviceId;
import org.onosproject.net.Host;
import org.onosproject.net.PortNumber;
import org.onosproject.net.config.NetworkConfigService;
import org.onosproject.net.device.DeviceService;
import org.onosproject.net.flow.FlowRule;
import org.onosproject.net.flow.FlowRuleService;
import org.onosproject.net.flow.criteria.PiCriterion;
import org.onosproject.net.group.GroupService;
import org.onosproject.net.host.HostEvent;
import org.onosproject.net.host.HostListener;
import org.onosproject.net.host.HostService;
import org.onosproject.net.intf.Interface;
import org.onosproject.net.intf.InterfaceService;
import org.onosproject.net.pi.model.PiActionId;
import org.onosproject.net.pi.model.PiActionParamId;
import org.onosproject.net.pi.model.PiMatchFieldId;
import org.onosproject.net.pi.runtime.PiAction;
import org.onosproject.net.pi.runtime.PiActionParam;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.onosproject.ngsdn.tutorial.common.Utils;
import org.onosproject.net.Port;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import java.util.Set;
import java.util.stream.Collectors;

import static org.onosproject.ngsdn.tutorial.AppConstants.INITIAL_SETUP_DELAY;

@Component(
    immediate = true,
    enabled = false
)
public class SetDirectionComponent {
    
    private final Logger log = LoggerFactory.getLogger(getClass());


    // private final DeviceListener deviceListener = new InternalDeviceListener();
    private final HostListener hostListener = new InternalHostListener();

    private ApplicationId appId;

    @Reference(cardinality = ReferenceCardinality.MANDATORY)
    private HostService hostService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY)
    private DeviceService deviceService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY)
    private InterfaceService interfaceService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY)
    private NetworkConfigService configService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY)
    private FlowRuleService flowRuleService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY)
    private GroupService groupService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY)
    private MastershipService mastershipService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY)
    private MainComponent mainComponent;

    
    final int    ENTER_INTERNAL = 1;
    final int    GO_OUTSIDE = 0;
 

    @Activate
    protected void activate(){
        appId = mainComponent.getAppId();

        
        hostService.addListener(hostListener);
        // mainComponent.scheduleTask(this::setUpAllDevices, INITIAL_SETUP_DELAY);
        log.info("Started");
    }

    @Deactivate
    protected void deactivate(){
        hostService.removeListener(hostListener);
        log.info("Stopped");
    }

    // 下发set_direction table
    private void learnHost(Host host,DeviceId deviceId,PortNumber inPort,PortNumber outPort,int dir){
        log.info("add set direction rule on {} inport {} outport {}",
                    deviceId,inPort,outPort);
        final String tableId = "IngressPipeImpl.check_ports";
        final PiCriterion setDiCriterion = PiCriterion.builder()
                            .matchExact(PiMatchFieldId.of("standard_metadata.egress_spec")
                            ,outPort.toLong())//出口
                            .matchExact(PiMatchFieldId.of("standard_metadata.ingress_port")
                            ,inPort.toLong())
                            .build();
        final PiAction setDireAction = PiAction.builder()
                            .withId(PiActionId.of("IngressPipeImpl.set_direction"))
                            .withParameter(new PiActionParam(
                                PiActionParamId.of("dir"),
                                dir))
                            .build();
        final FlowRule rule = Utils.buildFlowRule(deviceId, appId, tableId, setDiCriterion, setDireAction);

        flowRuleService.applyFlowRules(rule);
    }



    public class InternalHostListener implements HostListener{

        @Override
        public boolean isRelevant(HostEvent event){
            switch (event.type()) {
                case HOST_ADDED:
                    // Host added events will be generated by the
                    // HostLocationProvider by intercepting ARP/NDP packets.
                    break;
                case HOST_REMOVED:
                case HOST_UPDATED:
                case HOST_MOVED:
                default:
                    // Ignore other events.
                    // Food for thoughts: how to support host moved/removed?
                    return false;
            }
            final Host host = event.subject();
            final DeviceId deviceId = host.location().deviceId();
            return  mastershipService.isLocalMaster(deviceId);
        }

        @Override 
        public void event(HostEvent event){
            final Host host = event.subject();
            // Device and port where the host is located.
            final DeviceId deviceId = host.location().deviceId();
            final PortNumber internalport = host.location().port();
            final Set<PortNumber> post_to_hosts =  getHostFacingPorts(deviceId);
            final Set<PortNumber> device_ports_to_device =  deviceService.getPorts(deviceId).stream()
                                            .map(Port::number)
                                            .filter(device_port->!post_to_hosts.contains(device_port))
                                            .collect(Collectors.toSet());

            // mainComponent.getExecutorService().execute(()->{
            //     // log.info("{} event! host {},deviceId {},inport {},ouport {}",
            //     // event.type(),host.id(),deviceId,port,);
            //     device_ports_to_device.stream()
            //         .forEach(outsideport -> learnHost(host,deviceId,internalport,outsideport,GO_OUTSIDE));
            //     device_ports_to_device.stream()
            //         .forEach(outsideport -> learnHost(host,deviceId,outsideport,internalport,ENTER_INTERNAL));
            // });
        }
    }


        /**
     * Returns a set of ports for the given device that are used to connect
     * hosts to the fabric.
     *
     * @param deviceId device ID
     * @return set of host facing ports
     */
    private Set<PortNumber> getHostFacingPorts(DeviceId deviceId) {
        // Get all interfaces configured via netcfg for the given device ID and
        // return the corresponding device port number. Interface configuration
        // in the netcfg.json looks like this:
        // "device:leaf1/3": {
        //   "interfaces": [
        //     {
        //       "name": "leaf1-3",
        //       "ips": ["2001:1:1::ff/64"]
        //     }
        //   ]
        // }
        return interfaceService.getInterfaces().stream()
                .map(Interface::connectPoint)
                .filter(cp -> cp.deviceId().equals(deviceId))
                .map(ConnectPoint::port)
                .collect(Collectors.toSet());
    }

    private void setUpAllDevices(){
        // TODO
        // deviceService.getAvailableDevices().forEach(device ->{
        //     Set<PortNumber> post_to_hosts =  getHostFacingPorts(device.id());
        //     Set<PortNumber> device_ports_to_device =  deviceService.getPorts(device.id()).stream()
        //                                     .map(Port::number)
        //                                     .filter(device_port->!post_to_hosts.contains(device_port))
        //                                     .collect(Collectors.toSet());
                                            
        //     hostService.getConnectedHosts(device.id()).forEach(host -> {

        //     });                                
        //     device_ports_to_device.stream()
        //             .forEach(outsideport -> learnHost(host,deviceId,internalport,outsideport,0));
        //     device_ports_to_device.stream()
        //             .forEach(outsideport -> learnHost(host,deviceId,outsideport,internalport,1));
        // });
    }

}
